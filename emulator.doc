
=== Command-line switches ===

-B
  Bicycle mode; affects the meaning of some ports of the system device.

-D
  Use double buffering for the display.

-F
  Start in full screen mode.

-N
  Tells the window manager to omit the frame.

-Q
  Disable the mouse initially (it can still be enabled at run time).

-S
  Disallow the uxn program to change the screen size.

-T year.month.day.hours.minutes.seconds.wday.yday.yday.isdst
  Use a fixed value for the date/time, by numbers with dots in between. In
  this case, it will read the same values from the date/time device each
  time it is read. If you put less numbers than expected, then zero will
  be used for the remaining values; however, some programs will use these
  values to seed a random number generator and will not work correctly if
  they are zero.

-Y
  Enable file system access including writing.

-Z
  Use UTC instead of local time. (Has no effect in combination with -T.)

-a #
  Set audio. See the below section about audio for details. If both -a and
  -n switches are used, then audio data is written to stdout (it is signed
  16-bits big-endian).

-d
  Enable some debugging features. (Some will work even without this.)

-h #
  Set default screen height.

-i
  Hide the system mouse cursor. (The Uxn program might still draw its own
  mouse cursor, which most do.)

-j
  Enable key repeat for joypad emulation.

-n
  Disable GUI. This switch is required in order to read stdin; without it,
  stdin cannot be read (although command-line arguments still work).

-p #
  Select the palette. Valid palette numbers are 0 to 7, where 7 is the
  default setting and means that the running Uxn program can set colours.

-q
  Disable standard I/O.

-s #
  Define scroll amount.

-t #
  Set the frame rate, in milliseconds per frame.

-w #
  Set default screen width.

-x
  Enable extension device (only built-in extensions).

-y
  Enable read-only file system access.

-z #
  Set zoom level.


=== Function keys ===

F1
  Advance one frame, even if paused.

F2
  Mute/unmute audio.

F3
  Toggle the mouse mode. When the mouse mode is disabled, the mouse device
  does not work; the mouse vector is not called and the mouse coordinates
  and button state is not updated.

F4
  Change which graphics layers are displayed. Either both layers, or only
  foreground or only background.

F5
  Redraw screen. If the right shift key is also pushed, then also sends
  some debug output to stderr.

F6 / F7
  Palette selection.

F9
  Restart.

F10
  Quit.

PAUSE
  Pause/unpause VM.

PAGE-UP / PAGE-DOWN
  Scroll up/down.

Some programs use shortcut keys with control and letters. This does not
work in this program; therefore, END is an alias for the joypad A button
(the left control key also corresponds to the joypad A button, but if used
together with letter keys, will enter control characters instead).


=== Audio ===

The audio setting consists of a sequence of letters and numbers; each item
is one letter "a" to "z" followed by a number of any number of digits. (It
can optionally have - at first for negative numbers, although most options
cannot use negative numbers.)

b = Buffer size.

c = Number of output channels, which can be 1 (mono) or 2 (stereo).

e = Envelope speed. If not specified, then it is fifteenths of seconds.

m = If set to 1, then audio is initially muted. (This option is ignored if
the -n switch is used.)

n = Transpose amount.

r = Sample rate in hertz. Normally, this setting is also the sample rate
for middle C.

v = Output volume from 0 to 273. If not all of the four VM audio channels
are being used, then this number may be set higher than 273.

(Currently there is not the setting of interpolation, filter, etc.)


=== Extension device ===

Device fifteen is the extension device, which is defined as:
  f0 = vector *
  f1
  f2 = conventional memory transfer base *
  f3
  f4 = expanded memory transfer base *
  f5
  f6 = transfer length *
  f7
  f8 = command code / expanded memory pages
  f9 = device version / status
  fa = device seven UUID address *
  fb
  fc = device thirteen UUID address *
  fd
  fe = device fourteen UUID address *
  ff

(If the program file is too big to fit into conventional memory, then as
much as will fit of the rest will be loaded into expanded memory.)

Reading the command code port will be the number of expanded memory pages
(from 0 to 16). Writing the command code will execute the command, where
the high nybble specifies which command to do and the low nybble is the
parameter of that command. The command codes are:

* 0 = Copy conventional memory to expanded memory. The parameter is the
zero-based page number.

* 1 = Copy expanded memory to conventional memory. The parameter is the
zero-based page number.

* 2 = Clear the screen. If bit0 is set then clear the background layer,
and if bit1 is set then clear the foreground layer (set both bits to clear
both layers).

Writing to the UUID address ports will read sixteen bytes at that address
and then will set the device version field to the version number, which
can be zero if it is not implemented, an odd number for an unstable
implementation, or an even number for a stable implementation. (The memory
that it points to can be reused afterward with no problem.)

The vector is called after passing command-line arguments, but before any
other events occur. If accepting input from stdin, then it will also be
called after all input from stdin has been read.

The -x switch also changes the meaning of the delete and append ports of
the file device. See below about extended file device.

(Note: Using this feature will make the program not portable to other
implementations, and should be avoided if possible. However, it is
available if its functions (e.g. expanded memory) are needed in your
program for any reason. Most programs probably will not need expanded
memory; some might be able to optionally use it.)


=== Extended file device ===

If the -x switch is used, then the delete and append ports of the file
device have a different meaning than usual.

N.B. Use of these extensions in an implementation which does not support
them may cause files to be inadvertently deleted or corrupted. (This
implementation will ignore the delete port entirely if the -x switch is
not specified.) Furthermore, they may be changed in future; please make
a discussion if you have any intention to use these extensions, or even
to use the delete/append ports without these extensions. There are some
problems with the design of the file device, so I would want to suggest
these changes in order to make an improvement. Unfortunately, it is not
as simple as other devices, but it may be necessary if file handling is
to be working properly.

The delete port can be given any of the values:

* 0x00 = Does nothing.

* 0x01 = Delete the current file. (Not currently implemented.)

* 0x10 = Close the file.

* 0x11 = Open the file for reading. Success is 1 if opened.

* 0x12 = Open the file for writing. Success is 1 if opened.

* 0x80 to 0x8F = Seek. Bit0 and bit1 specify how much the length field
should be multiplied by, where 0 means zero, 1 means one, 2 means 64K,
and 3 is reserved. Bit2 and bit3 indicate where to seek and which way,
where 0 means forward from the current position, 1 means backward from
the current position, 2 means forward from the beginning, and 3 means
backward from the end.

Telling it to open a file will close it first, even if it is already open
in the correct mode. Also, seeking will not work unless the file is already
open, so it must first be opened, either by one of the above commands for
opening a file or by attempting to read from or write to it.

The append port has one of the following values:

* 0 = Files opened for writing are truncated.

* 1 = Files opened for writing will append at the end of the file.

* 2 = Files are opened for both reading and writing. In this case,
switching from reading to writing or vice-versa will not close and reopen
the file like it does in other cases. If writing is disabled, then this is
treated the same as 0.

Any value may be bitwise ORed by sixteen to refuse to open a file for
writing if the file already exists.


=== Extension loading ===

(This section describes a feature which is not implemented yet. Some
details might be changed before being implemented.)

Some extensions may be implemented internally if that is necessary, but it
is expected that most extensions might be external, so that it is possible
to avoid putting too many things into the emulator.

In the specified directory, are files named by the UUID (in lowercase
hexadecimal with hyphens) followed by ".so". This must export a function
named "uxn_extension_main", which is called the first time the extension
is loaded by the device UUID address fields being filled in by the Uxn
program. This function should return a pointer to the UxnExtension
structure for this extension, or null if it is somehow not valid. The
first argument is a pointer to the (binary) UUID, which can be used in
case the same file implements multiple extensions.

